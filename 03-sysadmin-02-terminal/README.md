# Практическое задание по теме «Работа в терминале 2»

1. Какого типа команда `cd`? Попробуйте объяснить, почему она именно такого типа; опишите ход своих мыслей, если считаете что она могла бы быть другого типа.

```bash
type cd

cd is a shell builtin
```

```bash
whereis cd

cd:
```

Команда `cd` (change directory) встроенная команда shell для изменения текущей директории. Не является файлом/процессом. Таким образом есть тип встроенных (builtin) команд, среди которых `cd`.

2. Какая альтернатива без pipe команде `grep <some_string> <some_file> | wc -l`? `man grep` поможет в ответе на этот вопрос. Ознакомьтесь с [документом](http://www.smallo.ruhr.de/award.html) о других подобных некорректных вариантах использования pipe.

Альтернатива: `grep -c <some_string> <some_file>`. Флаг `-c` выводит количество строк в которых найдено совпадение строки.

3. Какой процесс с PID `1` является родителем для всех процессов в вашей виртуальной машине Ubuntu 20.04?

```bash
pstree -p 1
```

```bash
systemd(1)─┬─ModemManager(990)─┬─{ModemManager}(1046)
           │                   └─{ModemManager}(1051)
           ├─NetworkManager(911)─┬─{NetworkManager}(967)
           │                     └─{NetworkManager}(969)
           ├─VGAuthService(867)
           ├─accounts-daemon(898)─┬─{accounts-daemon}(908)
           │                      └─{accounts-daemon}(922)
           ├─acpid(899)
           ├─avahi-daemon(902)───avahi-daemon(970)
           ├─bluetoothd(903)
           ├─colord(1549)─┬─{colord}(1556)
           │              └─{colord}(1558)
           ├─cron(904)
           ├─cups-browsed(994)─┬─{cups-browsed}(1057)
           │                   └─{cups-browsed}(1058)
           ├─cupsd(905)
           ├─dbus-daemon(907)
           ├─fwupd(2212)─┬─{fwupd}(2213)
           │             ├─{fwupd}(2214)
           │             ├─{fwupd}(2215)
           │             └─{fwupd}(2216)
           ├─gdm3(1031)─┬─gdm-session-wor(1578)─┬─gdm-x-session(1677)─┬─Xorg(1679)───{Xorg}(1688)
           │            │                       │                     ├─gnome-session-b(1691)─┬─ssh-agent(1758)
           │            │                       │                     │                       ├─{gnome-session-b}(1782+
           │            │                       │                     │                       └─{gnome-session-b}(1783+
           │            │                       │                     ├─{gdm-x-session}(1678)
           │            │                       │                     └─{gdm-x-session}(1689)
           │            │                       ├─{gdm-session-wor}(1579)
           │            │                       └─{gdm-session-wor}(1580)
           │            ├─{gdm3}(1048)
           │            └─{gdm3}(1052)
           ├─gnome-keyring-d(1611)─┬─{gnome-keyring-d}(1612)
           │                       ├─{gnome-keyring-d}(1614)
           │                       └─{gnome-keyring-d}(1790)
           ├─irqbalance(919)───{irqbalance}(941)
           ├─kerneloops(1171)
           ├─kerneloops(1180)
           ├─networkd-dispat(924)
           ├─polkitd(928)─┬─{polkitd}(948)
           │              └─{polkitd}(950)
           ├─rsyslogd(940)─┬─{rsyslogd}(971)
           │               ├─{rsyslogd}(972)
           │               └─{rsyslogd}(973)
           ├─rtkit-daemon(1105)─┬─{rtkit-daemon}(1107)
           │                    └─{rtkit-daemon}(1108)
           ├─snapd(947)─┬─{snapd}(1282)
           │            ├─{snapd}(1283)
           │            ├─{snapd}(1284)
           │            ├─{snapd}(1285)
           │            ├─{snapd}(1290)
           │            ├─{snapd}(1301)
           │            ├─{snapd}(1304)
           │            ├─{snapd}(1318)
           │            ├─{snapd}(1319)
           │            ├─{snapd}(1339)
           │            ├─{snapd}(1393)
           │            ├─{snapd}(1394)
           │            ├─{snapd}(2522)
           │            └─{snapd}(2523)
           ├─sshd(1053)
           ├─switcheroo-cont(951)─┬─{switcheroo-cont}(955)
           │                      └─{switcheroo-cont}(959)
           |
           ├─systemd-journal(382)
           ├─systemd-logind(953)
           ├─systemd-resolve(857)
           ├─systemd-timesyn(858)───{systemd-timesyn}(861)
           ├─systemd-udevd(435)
           ├─udisksd(954)─┬─{udisksd}(957)
           │              ├─{udisksd}(960)
           │              ├─{udisksd}(985)
           │              └─{udisksd}(1070)
           ├─unattended-upgr(1005)───{unattended-upgr}(1078)
           ├─upowerd(1268)─┬─{upowerd}(1274)
           │               └─{upowerd}(1275)
           ├─vmtoolsd(868)─┬─{vmtoolsd}(879)
           │               ├─{vmtoolsd}(880)
           │               └─{vmtoolsd}(1007)
           ├─whoopsie(1161)─┬─{whoopsie}(1194)
           │                └─{whoopsie}(1195)
           └─wpa_supplicant(961)

```

Процесс `systemd`.

4. Как будет выглядеть команда, которая перенаправит вывод stderr `ls` на другую сессию терминала?

Чтобы выяснить путь текущего терминала введём команду `tty`:

```bash
tty
```

```bash
/dev/pts/0
```

Для другой сессии используем путь `/dev/pts/1`:

```bash
ls 2>/dev/pts/1
```



5. Получится ли одновременно передать команде файл на stdin и вывести ее stdout в другой файл? Приведите работающий пример.

```bash
cat < file > file2
```

6. Получится ли находясь в графическом режиме, вывести данные из PTY в какой-либо из эмуляторов TTY? Сможете ли вы наблюдать выводимые данные?

Да, получится. Пример приводил в задании 4. Другой пример: `echo 'Hello World!' > /dev/pts/1`.

7. Выполните команду `bash 5>&1`. К чему она приведет? Что будет, если вы выполните `echo netology > /proc/$$/fd/5`? Почему так происходит? 

Команда `bash 5>&1` создаёт дескриптор с условным номером 5 и связывает его с std out текущего процесса. При выполнении команды `echo netology > /proc/$$/fd/5` выведится слово `netology`.

8. Получится ли в качестве входного потока для pipe использовать только stderr команды, не потеряв при этом отображение stdout на pty? Напоминаем: по умолчанию через pipe передается только stdout команды слева от `|` на stdin команды справа.
Это можно сделать, поменяв стандартные потоки местами через промежуточный новый дескриптор, который вы научились создавать в предыдущем вопросе.

Направляем созданный 5 дескриптор на 2, а 2 на 1: `ls dir 5>&2 2>&1 | grep dir`.

9. Что выведет команда `cat /proc/$$/environ`? Как еще можно получить аналогичный по содержанию вывод?

Команда выводит переменные окружения текущей сессии. Аналог — `env`.

10. Используя `man`, опишите что доступно по адресам `/proc/<PID>/cmdline`, `/proc/<PID>/exe`.

```bash
man proc | grep -n -B 1 -A 2 cmdline
man proc | grep -n -B 1 -A 2 exe
```

`/proc/<PID>/cmdline` — Этот доступный только для чтения файл содержит полную командную строку для процесса, если этот процесс не является зомби. В последнем случае в этом файле ничего нет: то есть чтение этого файла вернет 0 символов. Аргументы командной строки отображаются в этом файле как набор строк, разделенных нулевыми байтами ('\0'), с дополнительным нулевым байтом после последней строки.

`/proc/<PID>/exe` — В Linux 2.2 и более поздних версиях этот файл представляет собой символическую ссылку, содержащую фактический путь к выполняемой команде. Эта символическая ссылка может быть разыменована обычным образом; попытка открыть его откроет исполняемый файл. Вы даже можете ввести /proc/[pid]/exe, чтобы запустить другую копию того же исполняемого файла, который запускается процессом [pid]. Если путь был несвязан, символическая ссылка будет содержать строку «(удалено)», добавленную к исходному имени пути. В многопоточном процессе содержимое этой символической ссылки недоступно, если основной поток уже завершен (обычно вызовом pthread_exit(3)).

11. Узнайте, какую наиболее старшую версию набора инструкций SSE поддерживает ваш процессор с помощью `/proc/cpuinfo`.

```bash
cat /proc/cpuinfo | grep sse
```

Версия SSE: `sse4_2`.

12. При открытии нового окна терминала и `vagrant ssh` создается новая сессия и выделяется pty. Это можно подтвердить командой `tty`, которая упоминалась в лекции 3.2. Однако:

     ```bash
     vagrant@netology1:~$ ssh localhost 'tty'
     not a tty
     ```

     Почитайте, почему так происходит, и как изменить поведение.

Необходимо принудительно выделить rty с помощью флага `-t`:

```bash
ssh -t localhost 'tty'
```

13. Бывает, что есть необходимость переместить запущенный процесс из одной сессии в другую. Попробуйте сделать это, воспользовавшись `reptyr`. Например, так можно перенести в `screen` процесс, который вы запустили по ошибке в обычной SSH-сессии.

Для имитации тяжелого процесса создам 100000 файлов `touch {1..100000}`, затем прерву исполнение командой `Cmd + Z`. После чего зафиксирую количество созданных файлов. Так же зафиксирую PID нужного мне процесса. Перейду в новую сессию и выполню эту же команду с `reptyr`. 

```bash
touch {1..100000}

ls | wc -l
```

```bash
12802
````

```bash
ps -a | grep touch
```

```bash
   5719 pts/0    00:00:00 touch
```

```bash 
screen
touch {1..100000} reptyr 5719
exit
```

```bash
ls | wc -l
```

```bash
100001
```

100001-й файл — это файл `reptyr`.

14. `sudo echo string > /root/new_file` не даст выполнить перенаправление под обычным пользователем, так как перенаправлением занимается процесс shell'а, который запущен без `sudo` под вашим пользователем. Для решения данной проблемы можно использовать конструкцию `echo string | sudo tee /root/new_file`. Узнайте что делает команда `tee` и почему в отличие от `sudo echo` команда с `sudo tee` будет работать.

Команда `tee` используется для записи вывода в файл и обладает правами для записи в `root`.